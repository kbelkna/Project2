---
title: "Wine Data API Vignette"
author: "Annie Brinza & Kara Belknap"
date: '2022-10-07'
output: github_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This document is a vignette about contacting an API using functions
we've created to query, parse, and return well-structured data. We'll
then use our functions to obtain data from the API and do some
exploratory data analysis. Kara Belknap and Annie Brinza worked on this
project. We decided to use wine data from the food data API.
Specifically, we will be focusing on general wine recommendations, dish
pairings to go with a certain wine, and wine recommendations given a
certain dish. We will be building functions to accomplish all of that.

To interact with these functions, either a general wine type such as
"merlot" needs to be given, or a dish or cuisine type such as "Italian."
This will be detailed further for each of the API calls.

## Requirements

We used the following packages in the creation of this vignette. The
user will need to install and load these packages in order to interact
with the API.

```{r packages, message=FALSE}
library(httr)
library(tidyverse)
library(jsonlite)
```

## API Interaction Functions

In this section, we will define functions to interact with the various
wine APIs found
[here](https://spoonacular.com/food-api/docs#Wine-Guide). We will be
pulling from three different APIs: [Wine
Recommendation](https://spoonacular.com/food-api/docs#Wine-Recommendation),
[Wine Pairing](https://spoonacular.com/food-api/docs#Wine-Pairing), and
[Dish Pairing for
Wine](https://spoonacular.com/food-api/docs#Dish-Pairing-for-Wine).

The APIs do require an API key to access, which can be received by
signing up for a free account. For the free plan, the rate limit is 60
requests in one minute, and a total of 150 requests per day.

### Wine Recommendation Function

This function, `get_wine_recommendations`, will interact with the [Wine
Recommendation
API](https://spoonacular.com/food-api/docs#Wine-Recommendation). The
user will need to input `wine`, which should be a certain type of wine
(valid types given here: [Valid Wine
Types](https://spoonacular.com/food-api/docs#Wine-Guide). The user may
also specify `maxPrice` in USD, `minRating` (a value between 0 and 1,
which corresponds to the number of stars. 0.80 would indicate 4 out of 5
stars.), and `number` which is the max number of results to return (up
to 100).

A dataframe will be returned that has contains the wine recommendations
which meet the inputted parameters.

*Behind the function: First, we wrote a series of if statements to check
the validity of the user inputs along with appropriate error messages in
case of an inappropriate input. If all inputs were valid, we created an
output `API_string` using the paste0 function. Once we have this string,
we run the `GET` function from the `httr` package in order to pull the
data from the API. The raw data is stored as `wine_rec_data`. We then
use `fromJSON` from the `jsonlite` package to convert the data to a user
friendly format. Finally, we store the data of interest in a data frame
called `wine_recommendations`. This is what is returned by this
function.*

```{r wine_recommendations}

get_wine_recommendations <- function(wine, maxPrice = 50, minRating = 0.7, number = 10){
  
  api_key <- "80c8e25c825a4a3c93e5cae79f74b48c"
  
  if(is.character(wine) & is.numeric(maxPrice) & is.numeric(minRating) & is.numeric(number)){
      API_string <- paste0("https://api.spoonacular.com/food/wine/recommendation?apiKey=",
                       api_key,"&wine=",wine,"&maxPrice=",maxPrice,"&minRating=",minRating,"&number=",number)
  } else if(is.null(wine)){
    message <- "ERROR - please enter a type of wine from this list: https://spoonacular.com/food-api/docs#Wine-Guide"
    stop(message)
  } else if(!is.character(wine)){
    message <- "ERROR - please enter a string for the type of wine desired from this list: https://spoonacular.com/food-api/docs#Wine-Guide"
    stop(message)
  } else if(!is.numeric(maxPrice)){
    message <- "ERROR - please enter a numeric value for maxPrice"
    stop(message)
  } else if(!is.numeric(minRating)){
    message <- "ERROR - please enter a numeric value between 0 & 1 for minRating"
    stop(message)
  } else if(!is.numeric(number)){
    message <- "ERROR - please enter a numeric value between 1 & 100 for number"
    stop(message)
  }    
    
wine_rec_data <- GET(API_string)  
  
output_API <- fromJSON(rawToChar(wine_rec_data$content))

wine_recommendations <- output_API$recommendedWines

return(wine_recommendations)

} 
```

### Wine Pairing Function

This function will interact with the [Wine Pairing
API](https://spoonacular.com/food-api/docs#Wine-Pairing). The user will
need to input `food`, which can be a certain dish such as `steak`, or a
cuisine such as `Italian`. These inputs should be simple - a full recipe
name does not need to be given. A dataframe will be returned that has
the paired wine recommendations. These recommendations can then be used
in combination with the Wine Recommendation Function to find the exact
wine bottle desired.

```{r wine_pairing}
get_wine_pairings <- function(food, max_price = NULL){
  # API key generated by us
  api_key <- "a39a52136f9f4544b4fe6a062d255ea4"
  
  # Checking if the food is a valid input
  if(is.character(food)){
      API_string <- paste0("https://api.spoonacular.com/food/wine/pairing?apiKey=",
                       api_key,"&food=",food)
  } else if(is.null(food)){
    message <- "ERROR - please enter a type of dish or cuisine"
    stop(message)
  } else if(!is.character(food)){
    message <- "ERROR - please enter a string for the type of dish or cuisine desired"
    stop(message)
  }
  # Calling the API using the created call
  output_API <- fromJSON(
    API_string
  )
  # Checking to see if the API call failed and returning error message if so
  if(length(output_API$status) > 0){
    message <- paste0(output_API$message, ". Check for typos or try a simpler query")
    message2 <- paste0("If looking for a certain cuisine, try one of these: https://spoonacular.com/food-api/docs#Cuisines")
    final_message <- paste(message, message2, sep = "\n")
    stop(final_message)
  } else if(length(output_API$pairedWines) == 0){
    message <- paste0("Sorry, no paired wines found for ",food,". Try a different dish or cuisine")
    stop(message)
  }
  
  # Creating dataframe of wine pairings
  wine_pairings <- as.data.frame(output_API$pairedWines)
  colnames(wine_pairings) <- "wine_types"
  
  # Returning the wine pairings
  return(wine_pairings)
}

```

### Dish Pairing for Wine

This function will interact with the [Dish Pairing
API](https://spoonacular.com/food-api/docs#Dish-Pairing-for-Wine). The
user will need to input a `wine` they would like a dish recommendation
for, such as `merlot`. The API will return a list of suggested dishes to
go with the wine, such as `burger`.

```{r dish_pairing}
get_dish_pairings <- function(wine){
  # API key generated by us
  api_key <- "a39a52136f9f4544b4fe6a062d255ea4"
  
  # Checking if the wine is a valid input
  if(is.character(wine)){
    # Replacing any underscores with spaces so the API works
      if(grepl("_",wine, fixed)){
        wine <- gsub("_", " ", wine)
      }

      API_string <- paste0("https://api.spoonacular.com/food/wine/dishes?apiKey=",
                       api_key,"&wine=",wine)
  } else if(is.null(wine)){
    message <- "ERROR - please enter a type of wine"
    stop(message)
  } else if(!is.character(wine)){
    message <- "ERROR - please enter a string for the type of wine that needs pairing"
    stop(message)
  }
  # Calling the API using the created call
  output_API <- fromJSON(
    API_string
  )
  # Checking to see if the API call failed and returning error message if so
  if(length(output_API$status) > 0){
    message <- paste0(output_API$message, ". Check for typos or try a simpler query.")
    stop(message)
  }
  
  # Creating dataframe of dish recommendations
  dish_recommendations <- as.data.frame(output_API$pairings)
  colnames(dish_recommendations) <- "dishes"
  
  # Returning the dish recommendations
  return(dish_recommendations)
}
```

## Exploratory Data Analysis

For this exploratory data analysis, we started by investigating whether
price really affected the quality of the wine, using the Wine
Recommendation API function.

### Wine Recommendation Exploration

```{r wine_recs_eda}

red_wines_subset <- c("pinot_noir", "malbec", "zinfandel", "cabernet_sauvignon", "shiraz","merlot")
red_wines_printable <- c("Pinot Noir", "Malbec", "Zinfandel", "Cabernet Sauvignon", "Shiraz","Merlot")

red_wines_rec <- lapply(red_wines_subset, get_wine_recommendations, maxPrice = 100, minRating=0, number=100)
wine_results <- as.data.frame(bind_rows(red_wines_rec, .id = "id"))


wine_results$id <- as.numeric(wine_results$id)
wine_results$price2 <- parse_number(wine_results$price)


wine_results_final <- wine_results %>%
  mutate(wine_type = red_wines_printable[id], 
         ratingClass = ifelse(averageRating > 0.85, "high rating", 
          ifelse(averageRating < 0.75, "low rating", "mid rating")), 
         priceClass = ifelse(price2 > 50, "high cost", 
                        ifelse(price2 < 20, "low cost", "mid cost"))) %>%
  filter(ratingCount > 2)


summaryTable <- wine_results_final %>%
  group_by(wine_type) %>%
  summarise(avgRating = mean(averageRating), avgPrice = mean(price2), ratio = avgRating/avgPrice*100) 
summaryTable


myScatterPlot <- ggplot(wine_results_final, aes(x=averageRating, y = price2, color=wine_type))
myScatterPlot + geom_point() +
  labs(x="Average Rating", y="Price (USD)", title = "Average Rating by Price") 

correlation <- cor(wine_results_final$price2, wine_results_final$averageRating)
correlation

myHistogram <- ggplot(wine_results_final, aes(x = price2,  fill = ratingClass))
myHistogram + geom_histogram(binwidth = 10) +
  labs(x = "Wine Cost", y = "Number of Wines", title = "Count of Wines by Price")

myBoxPlot <- ggplot(wine_results_final, aes(x = wine_type, y = price2))
myBoxPlot + geom_boxplot() + 
  geom_jitter(aes(color = ratingClass)) + 
  labs(x = "Type of Wine", y = "Cost", title = "Type of Wine by Cost")

```

### Wine Pairings Exploration

The next investigation was into wine pairings. In this case, there is a
lot that could possibly be looked at and so we needed to narrow down our
focus. We decided to look at wine recommendations across several
different cuisines to see differences there. We chose cuisines from
several different continents because we were also curious as to whether
any wine recommendations would be similar within the same regions.

```{r wine_pairings_eda}
cuisine_list <- c("Italian", "Greek", "French", "Spanish", "Indian", "Korean", 
                  "Japanese",  "Thai", "Southern","Mexican", "Caribbean", "Cajun")
wine_pairings_list <- lapply(cuisine_list, get_wine_pairings)
wine_pairings_df <- as.data.frame(do.call(cbind, wine_pairings_list))
colnames(wine_pairings_df) <- cuisine_list

# Going to reshape the data into long format so that it is easier to work with
wine_pairings_long <- pivot_longer(wine_pairings_df, cols = everything())
colnames(wine_pairings_long) <- c("cuisine", "wine")

# Now need to create a new variable that is the region associated with each cuisine
wine_pairings_long <- wine_pairings_long %>% 
  mutate(region = ifelse(cuisine %in% c("Italian", "Greek", "French", "Spanish"),
                         "European", ifelse(cuisine %in% c("Indian", "Korean",
                          "Thai", "Japanese"), "Asian", "North American")))

# Creating a two-way contigency table to see counts of wine by region
table(wine_pairings_long$region, wine_pairings_long$wine)

# As we can see in the contigency table, there are some wines that are similar
# across the regions! Riesling is popular both in Asian and North American cuisine

# Now going to create a wine color variable to see if red or white is more popular in each
# region
wine_pairings_long <- wine_pairings_long %>% 
  mutate(wine_color = ifelse(wine %in% c("agiorgitiko", "bordeaux", "grenache",
                      "pinot noir", "tempranillo", "zinfandel", "chianti"), "Red", 
                      ifelse(wine %in% c("albarino", "assyrtiko", "chenin blanc",
                      "gewurztraminer", "gruener veltliner", "moschofilero", 
                      "pinot gris", "riesling", "sauvignon blanc", "trebbiano",
                      "verdicchio", "white burgundy"), "White", ifelse(wine %in%
                       c("champagne", "sparkling wine"), "Sparkling", ifelse(wine %in%
                       c("rose wine", "sparkling rose"), "Rose", "Other")))))

# Now looking at wine color by region using a barplot
g <- ggplot(wine_pairings_long, aes(x = region))
g + geom_bar(aes(fill = wine_color), position = "fill") + labs(x = "Regions", y = "Percent of Total", title = "Wine Colors by Region") + scale_fill_manual(values = c("black","darkred", "coral1", "lemonchiffon2", "ivory"))

```

Interestingly, from the plot we can see that there are no red wines
recommended for Asian cuisine, while European cuisine has the highest
proportion of red wines out of all the regions, at almost 50%. North
American cuisine has the widest variety of wine colors recommended, but
white is still the majority.

### Dish Recommendation Exploration

The next investigation was into dish recommendations - we were curious
about the differences in dishes recommended across sub-varieties of
wine. We wanted to know if there were certain dishes a merlot, for
example, paired better with than a pinot noir. In order to accomplish
this, we used the [Wine
Guide](https://spoonacular.com/food-api/docs#Wine-Guide) to create a
list of all the red wines (since we tend to drink more red than white)
and made function calls for all of those wines. Not all wines had
recommendations, so we simplified the list to include only those that
did. We merged that data together so that it could be explored.

```{r red_wine_exploration}
# List of all the red wines
red_wines <- c("zweigelt",  "barbera_wine", "primitivo", "pinot_noir", "nebbiolo",
               "red_burgundy", "rioja",  "grenache", "malbec", "zinfandel", "sangiovese",
               "cabernet_sauvignon", "tempranillo", "shiraz","merlot", "nero_d'avola",
               "bordeaux", "port", "gamay", "dornfelder", "sparkling_red_wine", 
               "pinotage", "agiorgitiko")

red_wines_list <- lapply(red_wines, get_dish_pairings)
# Associating the dishes with the wines
names(red_wines_list) <- red_wines

# Now we need to reshape the data to see for each wine
# Going to have it in long format for easier EDA
# red_wines_unlist <- sapply(red_wines_list, "length<-", max(lengths(red_wines_list)))
# red_wines_df <- as.data.frame(sapply(red_wines_unlist, "length<-", max(lengths(red_wines_unlist))))
# colnames(red_wines_df) <- red_wines
red_wines_df <- as.data.frame(unlist(red_wines_list))
red_wines_df <- red_wines_df %>%
  rownames_to_column("wine_original") %>%
    separate(col = wine_original, into = c("wine", "dishes"), sep = "\\.") %>%
      rename(dish = `unlist(red_wines_list)`) %>%
        select("wine", "dish")

# Creating a contingency table to see how frequently each dish is recommended
table(red_wines_df$dish)

# Creating a barplot to see how many dishes were recommended per type of wine
# First creating a new column for type of wine
red_wines_df <- red_wines_df %>% 
  mutate(wine_type = ifelse(wine %in% c("bordeaux", "port", "gamay", "dornfelder", "pinotage",
                                    "agiorgitiko"), "Regular", 
                        ifelse(wine == "sparkling_red_wine", "Sparkling", "Dry")))

g <- ggplot(red_wines_df, aes(x = wine))
g + geom_bar(aes(fill = wine_type)) + labs(x = "Wines", y = "Dishes Count", title = "Dishes Recommended Count by Type of Wine") + theme(axis.text.x = element_text(angle = 45))

# A natural next question is - how many dishes are in common across similar wine types?
# From the contigency table, we saw that chili and steak were the most recommended at 
# 4 wines each. Are these wines of the same type?
red_wines_df %>% subset(dish %in% c("chili", "steak"))
# Yes!
# Now let's check that across all repeated dishes
repeated_dishes <- red_wines_df %>% 
  count(dish) %>%
  subset(n > 1)
red_wines_repeated <- red_wines_df %>% subset(dish %in% repeated_dishes$dish)
g <- ggplot(red_wines_repeated, aes(x = dish))
g + geom_bar(aes(fill = wine_type)) + labs(x = "Dishes", y = "Wine Count", title = "Repeated Dishes by Type") + theme(axis.text.x = element_text(angle = 45))

# As we can see by the graph, all except for coq au vin have the same wine type that generated the recommendation
```
